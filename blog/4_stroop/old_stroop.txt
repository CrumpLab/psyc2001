---
title: "Stroop"
author: "Matt Crump"
output:
  html_document:
    template: templates/jspsychr_template.html
    mathjax: null
    highlight: null
    theme: null
    css: [css/custom.css,jspsych-6.3.1/css/jspsych.css]
    self_contained: no
    toc: false
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message=FALSE, warning=FALSE)
```


```{r, results='asis'}
# load plugins and js 
cat('
<script src="jatos.js"></script>
<script src="jspsych-6.3.1/jspsych.js"></script>
<script src="jspsych-6.3.1/plugins/jspsych-preload.js"></script>
<script src="jspsych-6.3.1/plugins/jspsych-external-html2.js"></script>
<script src="jspsych-6.3.1/plugins/jspsych-external-html.js"></script>
<script src="jspsych-6.3.1/plugins/jspsych-html-keyboard-response.js"></script>
<script src="jspsych-6.3.1/plugins/jspsych-survey-multi-choice.js"></script>
<script src="jspsych-6.3.1/plugins/jspsych-survey-html-form.js"></script>
')

```


```{r, results="asis"}
# Define stimuli in R, output as script 
# note: this is an r code chunk, with results = "asis"

library(jspsychr)
library(dplyr)

# create dataframe to define stimuli
stroop_stim <- data.frame( stimulus = length(16),
                           word = rep(c("red","green","blue","yellow"), each=4),
                           color = rep(c("red","green","blue","yellow"), 4),
                           c_response = rep(c("r","g","b","y"), 4),
                           stim_type = length(16),
                           id = "stroop_stim",
                           fontsize = "60pt") %>%
  mutate(stim_type = as.numeric(word==color)) %>%
  mutate(stim_type = recode(stim_type, `1` = "congruent", `0` = "incongruent"))

# add more congruent items to make it 50/50
get_congruent <- stroop_stim %>%
  filter(stim_type == "congruent")

stroop_stim <- rbind(stroop_stim, 
                     get_congruent,
                     get_congruent
                     )

# write html definitions to the stimulus column
# note this could be added as a pipe to the above, setting df=.
stroop_stim$stimulus <- html_stimulus(df = stroop_stim, 
                                html_content = "word",
                                html_element = "p",
                                column_names = c("color","fontsize"),
                                css = c("color", "font-size"),
                                id = "id")

# create json object from dataframe
stimulus_json <- stimulus_df_to_json(df = stroop_stim,
                                     stimulus = "stimulus",
                                     data = c("word","color","c_response","stim_type"))

# write json object to script
write_to_script(stimulus_json,"test_stimuli")
```


```{js}
/* Run Experiment
Define jsPsych plugins
Initialize and run
*/

var rand_subject_id = jsPsych.randomization.randomID(16);
// add the ID to the data for all trials
jsPsych.data.addProperties({ID: rand_subject_id});

/* experiment parameters */

var runshort = true;
if(runshort == true){

}

var reps_per_trial_type = 1;

/* define plugins */

/* Welcome screen */
var welcome = {
  type: "external-html",
  url: 'consent/welcome.html',
  cont_btn: "continue"
};

/* Consent Screen */
var consent = {
  type: "external-html2",
  url: 'consent/consent.html',
  cont_btn: ["accept","decline"],
  on_finish: function(data){
    if(data.response == "decline"){
      jatos.abortStudy('Thank you for considering participation.');
    }
  }
};

/* Demographics */

var demographics = {
  type: 'survey-html-form',
  preamble: `<p>We are collecting basic demographic information as a part of this study</p>
  <p>Please answer the following questions </p>`,
  html: `<label for="age">Age (enter or select a number):</label>
<input type="number" id="age" name="age" min="1" max="100" />
<br>
<label for="sex-select">What is your sex?</label>
<select name="sex" id="sex-select">
    <option value="">choose</option>
    <option value="female">Female</option>
    <option value="male">Male</option>
</select>
<br>
<label for="hand-select">What is your handedness?</label>
<select name="hand" id="hand-select">
    <option value="">choose</option>
    <option value="Left">Left</option>
    <option value="Right">Right</option>
    <option value="Both">Both</option>
</select>
<br>
<label for="vision-select">How is your vision?</label>
<select name="vision" id="vision-select">
    <option value="">choose</option>
    <option value="Normal">Normal vision</option>
    <option value="Corrected">Corrected-to-normal vision</option>
    <option value="Impaired">Impaired vision</option>
</select>
<br>
<label for="english-select">What is your English ability?</label>
<select name="english" id="english-select">
    <option value="">choose</option>
    <option value="First">First-language</option>
    <option value="Second">Second-language</option>
    <option value="None">No-English ability</option>
</select>
<br>
<p> Thank you, press continue </p>
<br><br>`,
  autofocus: 'test-resp-box'
};

/*set up instructions block*/
var instructions1 = {
  type: "html-keyboard-response",
  stimulus: "<p>In this task, you will see word in a color</p>"+
    "<p style='color:red;font-size:60pt;'>BLUE</p>"+
    "<p>Press r, g, b, or y to identify the color, not the word</p>"+
    "<p>E.g., press r for red in this example</p>"+
    "<p>Make your responses as quickly and accurately as possible</p>"+
    "<p>Press any key to begin.</p>",
  post_trial_gap: 1000
};

/* defining test timeline */
var phase_practice = {
  timeline: [{
    type: 'html-keyboard-response',
    choices: ["r","g","b","y"],
    prompt: "<p>press r, g, b, or y to identify color </p>",
    trial_duration: 2000,
    response_ends_trial: true,
    stimulus: jsPsych.timelineVariable('stimulus'),
    data: jsPsych.timelineVariable('data'),
    on_finish: function(data){
      var correct = false;
      if(data.c_response == data.response && data.rt > -1){
        correct = true;
      }
      data.correct = correct;
      data.phase = "practice";
    }
  },{
  type: 'html-keyboard-response',
  stimulus: function(){
    // The feedback stimulus
    var last_trial_correct = jsPsych.data.get().last(1).values()[0].correct;
    if(last_trial_correct){
      return "<p>Correct!</p>";
    } else {
      return "<p>Wrong.</p>";
    }
  },
  trial_duration: 500,
  post_trial_gap: function() {
        return Math.floor(Math.random() * 500) + 500;
    }
}],
  timeline_variables: test_stimuli,
  sample: {type: 'fixed-repetitions', size: reps_per_trial_type}
};

/*WORD focus instructions*/
var instructions_focus_word = {
  type: "html-keyboard-response",
  stimulus: `<h2> Focus on the words </h2>
  <p> In this phase you will repeat the same basic task </p>
  <p> However, please attempt to focus your attention as much as possible on the word information </p>
  <p> Your task is still to respond to the color of the word, not the identity of the word </p>
  <p> Press any key to continue</p>`,
  post_trial_gap: 1000
};

var phase_focus = {
  timeline: [{
  type: 'html-keyboard-response',
  stimulus: `<h2>FOCUS ON WORDS</h2>`,
  trial_duration: 500,
  response_ends_trial: false
  },
    {
    type: 'html-keyboard-response',
    choices: ["r","g","b","y"],
    trial_duration: 2000,
    response_ends_trial: true,
    stimulus: jsPsych.timelineVariable('stimulus'),
    data: jsPsych.timelineVariable('data'),
    on_finish: function(data){
      var correct = false;
      if(data.c_response == data.response && data.rt > -1){
        correct = true;
      }
      data.correct = correct;
      data.phase = "focus_word";
    }
  },{
  type: 'html-keyboard-response',
  stimulus: function(){
    // The feedback stimulus
    var last_trial_correct = jsPsych.data.get().last(1).values()[0].correct;
    if(last_trial_correct){
      return "<p>Correct!</p>";
    } else {
      return "<p>Wrong.</p>";
    }
  },
  trial_duration: 500,
  post_trial_gap: function() {
        return Math.floor(Math.random() * 500) + 500;
    }
}],
  timeline_variables: test_stimuli,
  sample: {type: 'fixed-repetitions', size: reps_per_trial_type}
};

/*WORD ignore instructions*/
var instructions_ignore_word = {
  type: "html-keyboard-response",
  stimulus: `<h2> Ignore the words </h2>
  <p> In this phase you will repeat the same basic task </p>
  <p> However, please attempt to ignore the word information as much as possible </p>
  <p> Your task is still to respond to the color of the word, not the identity of the word </p>
  <p> Press any key to continue</p>`,
  post_trial_gap: 1000
};

var phase_ignore = {
  timeline: [{
  type: 'html-keyboard-response',
  stimulus: `<h2>IGNORE WORDS</h2>`,
  trial_duration: 500,
  response_ends_trial: false
  },{
    type: 'html-keyboard-response',
    choices: ["r","g","b","y"],
    trial_duration: 2000,
    response_ends_trial: true,
    stimulus: jsPsych.timelineVariable('stimulus'),
    data: jsPsych.timelineVariable('data'),
    on_finish: function(data){
      var correct = false;
      if(data.c_response == data.response && data.rt > -1){
        correct = true;
      }
      data.correct = correct;
      data.phase = "ignore_word";
    }
  },{
  type: 'html-keyboard-response',
  stimulus: function(){
    // The feedback stimulus
    var last_trial_correct = jsPsych.data.get().last(1).values()[0].correct;
    if(last_trial_correct){
      return "<p>Correct!</p>";
    } else {
      return "<p>Wrong.</p>";
    }
  },
  trial_duration: 500,
  post_trial_gap: function() {
        return Math.floor(Math.random() * 500) + 500;
    }
}],
  timeline_variables: test_stimuli,
  sample: {type: 'fixed-repetitions', size: reps_per_trial_type}
};
    
    
/*defining debriefing block*/
var debrief = {
  type: "html-keyboard-response",
  stimulus: function() {
    var practice_congruent_rt = Math.round(jsPsych.data.get().filter({phase: 'practice', correct: true, stim_type: 'congruent'}).select('rt').mean());
    var practice_incongruent_rt = Math.round(jsPsych.data.get().filter({phase: 'practice', correct: true, stim_type: 'incongruent'}).select('rt').mean());
    var focus_congruent_rt = Math.round(jsPsych.data.get().filter({phase: 'focus_word', correct: true, stim_type: 'congruent'}).select('rt').mean());
    var focus_incongruent_rt = Math.round(jsPsych.data.get().filter({phase: 'focus_word', correct: true, stim_type: 'incongruent'}).select('rt').mean());
    var ignore_congruent_rt = Math.round(jsPsych.data.get().filter({phase: 'ignore_word', correct: true, stim_type: 'congruent'}).select('rt').mean());
    var ignore_incongruent_rt = Math.round(jsPsych.data.get().filter({phase: 'ignore_word', correct: true, stim_type: 'incongruent'}).select('rt').mean());
    return "<p> Practice Phase </p>" +
    "<p> Congruent mean RT = <strong>" + practice_congruent_rt + "ms</strong>.</p>"+
    "<p> Incongruent mean RT = <strong>" + practice_incongruent_rt + "ms</strong>.</p>"+
    "<p> Stroop effect =  <strong>" + (practice_incongruent_rt-practice_congruent_rt)  + "ms</strong>.</p>"+
    "<p> Focus Word Phase </p>" +
    "<p> Congruent mean RT = <strong>" + focus_congruent_rt + "ms</strong>.</p>"+
    "<p> Incongruent mean RT <strong>" + focus_incongruent_rt + "ms</strong>.</p>"+
    "<p> Stroop effect =  <strong>" + (focus_incongruent_rt-focus_congruent_rt)  + "ms</strong>.</p>"+
    "<p> Ignore Word Phase </p>" +
    "<p> Congruent mean RT = <strong>" + ignore_congruent_rt + "ms</strong>.</p>"+
    "<p> Incongruent mean RT <strong>" + ignore_incongruent_rt + "ms</strong>.</p>"+
    "<p> Stroop effect =  <strong>" + (ignore_incongruent_rt-ignore_congruent_rt)  + "ms</strong>.</p>"+
    "<p>Press any key to complete the experiment. Thank you!</p>";
  },
  on_start:  function() {
        var resultJson = jsPsych.data.get().json();
        jatos.submitResultData(resultJson);
     }
};    
    
    
/*push to timeline*/

var timeline = [];

timeline.push(welcome);
timeline.push(consent);
timeline.push(demographics);
timeline.push(instructions1);
timeline.push(phase_practice);

var choose_order = jsPsych.randomization.sampleWithoutReplacement([1,0],1);

if (choose_order == 1){
timeline.push(instructions_focus_word,phase_focus,instructions_ignore_word,phase_ignore);
} else {
timeline.push(instructions_ignore_word,phase_ignore,instructions_focus_word,phase_focus);
}

timeline.push(debrief);


/* Run */

var run_simulation = false;
var run_jatos = true;

if(run_jatos === true){
  jatos.onLoad(function() {
    jsPsych.init({
        timeline: timeline,
        on_finish: function() {
          var resultJson = jsPsych.data.get().json();
          jatos.submitResultData(resultJson, jatos.startNextComponent());
        },
        on_trial_start: function(trial) {
          if(run_simulation == true){
            trial.trial_duration = 0;
          }
      }
      });
  });
} else {
  jsPsych.init({
      timeline: timeline,
      on_finish: function() {
       jsPsych.data.displayData();
      },
      on_trial_start: function(trial) {
        if(run_simulation == true){
          trial.trial_duration = 0;
        }
    }
    });
}

```
